train_size <- as.integer(0.95 * length(ts_all))
test_size <- length(ts_all) - train_size
ts_train <- head(ts_all, train_size)
ts_test <- tail(ts_all, test_size)
# Forecasting of naive preddictor, as a baseline model.
baseline_error <- mean(
diff(ts_test) ** 2
)
cat(baseline_error)
autoplot(ts_train) +
ggtitle("Number of sunspots") +
xlab("Date") +
ylab("Exchange Rate") +
theme(plot.title = element_text(size=8, face="bold"))
# Determine the d number.
ndiffs(ts_train)
# Inspect the transformed sequence
transformed <- diff(ts_train, lag=1, differences=1)
ACF <- Acf(transformed, plot=TRUE, lag.max=34) # q=1
PACF <-Pacf(transformed, plot=TRUE, lag.max=34) # p=8
autoplot(transformed) +
ggtitle("Differenced Series") +
xlab("Date") +
ylab("Transformed")
# Test stationarity
adf.test(transformed)
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=30, max.P=30, max.q=30, max.Q=30, max.d=3, max.D=3, trace=TRUE)
# ==== Fit and Evaluate the Model ====
model <- arima(ts_train, order=c(1,1,1))
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=30, max.P=30, max.q=30, max.Q=30, max.d=3, max.D=3, trace=TRUE)
# Train and test spliting
train_size <- as.integer(0.8 * length(ts_all))
test_size <- length(ts_all) - train_size
ts_train <- head(ts_all, train_size)
ts_test <- tail(ts_all, test_size)
# Forecasting of naive preddictor, as a baseline model.
baseline_error <- mean(
diff(ts_test) ** 2
)
cat(baseline_error)
autoplot(ts_train) +
ggtitle("Number of sunspots") +
xlab("Date") +
ylab("Exchange Rate") +
theme(plot.title = element_text(size=8, face="bold"))
# Determine the d number.
ndiffs(ts_train)
# Inspect the transformed sequence
transformed <- diff(ts_train, lag=1, differences=1)
ACF <- Acf(transformed, plot=TRUE, lag.max=34) # q=1
PACF <-Pacf(transformed, plot=TRUE, lag.max=34) # p=8
autoplot(transformed) +
ggtitle("Differenced Series") +
xlab("Date") +
ylab("Transformed")
# Test stationarity
adf.test(transformed)
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=30, max.P=30, max.q=30, max.Q=30, max.d=3, max.D=3, trace=TRUE)
# ==== Fit and Evaluate the Model ====
model <- arima(ts_train, order=c(1,1,1))
res <- residuals(model)
mse <- mean(res**2)
rmse <- sqrt(mse)
err_abspec <- abs(res)/ts_train
mape <- mean(
err_abspec[err_abspec != Inf]
)
cat("MSE:", mse, "RMSE:", rmse, "MAPE:", mape)
coeftest(model)
# Simple forecast
fore <- forecast::forecast(model, h=1, level=c(99))
autoplot(fore)
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=10, max.P=10, max.q=10, max.Q=10, max.d=3, max.D=3, trace=TRUE)
ACF <- Acf(transformed, plot=TRUE, lag.max=34) # q=1
PACF <-Pacf(transformed, plot=TRUE, lag.max=34) # p=8
# ==== Fit and Evaluate the Model ====
model <- arima(ts_train, order=c(3,1,3))
res <- residuals(model)
mse <- mean(res**2)
rmse <- sqrt(mse)
err_abspec <- abs(res)/ts_train
mape <- mean(
err_abspec[err_abspec != Inf]
)
cat("MSE:", mse, "RMSE:", rmse, "MAPE:", mape)
coeftest(model)
ts_train
# Simple forecast
fore <- forecast::forecast(model, h=1, level=c(99))
autoplot(fore)
# May 17 2019
# Benchmark ARIMA for sunspot data.
# We use the basic sunspot time series data
library(fpp2)
library(ggfortify)
library(forecast)
library(stats)
library(aTSA)
library(lmtest)
setwd("/Users/tianyudu/Documents/Academics/EconForecasting/AnnEconForecast")
df <- read.csv("./data/sunspots.csv", header=TRUE, sep=",", col.names=c("Year", "Sunspots"))
ts_all <- ts(df$Sunspots,start=c(1700),frequency=1)
# Train and test spliting
train_size <- as.integer(0.8 * length(ts_all))
test_size <- length(ts_all) - train_size
ts_train <- head(ts_all, train_size)
ts_test <- tail(ts_all, test_size)
# Forecasting of naive preddictor, as a baseline model.
baseline_error <- mean(
diff(ts_test) ** 2
)
cat(baseline_error)
# ==== End ====
autoplot(ts_train) +
ggtitle("Number of sunspots") +
xlab("Year") +
ylab("Sunspot") +
theme(plot.title = element_text(size=8, face="bold"))
# Determine the d number.
ndiffs(ts_train)
# Inspect the transformed sequence
transformed <- diff(ts_train, lag=1, differences=1)
ACF <- Acf(transformed, plot=TRUE, lag.max=34) # q=1
PACF <-Pacf(transformed, plot=TRUE, lag.max=34) # p=8
autoplot(transformed) +
ggtitle("Differenced Series") +
xlab("Date") +
ylab("Transformed")
# Test stationarity
adf.test(transformed)
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=10, max.P=10, max.q=10, max.Q=10, max.d=3, max.D=3, trace=TRUE)
# ==== Fit and Evaluate the Model ====
model <- arima(ts_train, order=c(2,0,1))
res <- residuals(model)
mse <- mean(res**2)
rmse <- sqrt(mse)
err_abspec <- abs(res)/ts_train
mape <- mean(
err_abspec[err_abspec != Inf]
)
cat("MSE:", mse, "RMSE:", rmse, "MAPE:", mape)
coeftest(model)
# Simple forecast
fore <- forecast::forecast(model, h=1, level=c(99))
autoplot(fore)
# Rolling forecast
rf <- c()
for (i in c(1: test_size)){
# Refit model
model <- arima(
head(ts_all, train_size+i-1),
# To predict the first element of the test set, we use the whole training set.
# To predict the k-th element of the test set (i.e. train_size+k th element), use all previouse train_size+k-1 elements.
order=c(2,0,1)
)
# Produce one step forecast
f <- forecast::forecast(model, h=1, level=c(99))
rf <- c(rf, f$mean)  # Add rolling forecast.
}
ts_rf <- ts(rf, start=time(ts_test)[1])
combined <- cbind("Rolling Forecast"=ts_rf, "Actual"=ts_test)
autoplot(combined) +
ggtitle("One Step Rolling Forecasting on Test Set") +
xlab("Date") +
ylab("Sunspot")
# Performance Metrics
mse_test <- mean((ts_rf - ts_test) ** 2)
rmse_test <- sqrt(mse_test)
cat("Test MSE:", mse, "RMSE:", rmse)
autoplot(fore)
# Jun. 10, 2019
# Exchange rate prediction using ARIMA models
library(fpp2)
library(ggfortify)
library(forecast)
library(stats)
library(aTSA)
library(lmtest)
setwd("/Users/tianyudu/Documents/Academics/EconForecasting/AnnEconForecast")
df <- read.csv("./data/DEXCAUS.csv", header=TRUE, sep=",", col.names=c("Date", "Ex"))
df <- subset(df, Ex != ".")
ts_all <- ts(df$Ex)
# Train and test spliting
train_size <- as.integer(0.95 * length(ts_all))
test_size <- length(ts_all) - train_size
ts_train <- head(ts_all, train_size)
ts_test <- tail(ts_all, test_size)
# Forecasting of naive preddictor, as a baseline model.
baseline_error <- mean(
diff(ts_test) ** 2
)
cat(baseline_error)
# ==== End ====
autoplot(ts_train) +
ggtitle("Number of sunspots") +
xlab("Date") +
ylab("Exchange Rate") +
theme(plot.title = element_text(size=8, face="bold"))
# Determine the d number.
ndiffs(ts_train)
# Inspect the transformed sequence
transformed <- diff(ts_train, lag=1, differences=1)
ACF <- Acf(transformed, plot=TRUE, lag.max=34) # q=3
PACF <-Pacf(transformed, plot=TRUE, lag.max=34) # p=3
autoplot(transformed) +
ggtitle("Differenced Series") +
xlab("Date") +
ylab("Transformed")
# Test stationarity
adf.test(transformed)
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=10, max.P=10, max.q=10, max.Q=10, max.d=3, max.D=3, trace=TRUE)
# ==== Fit and Evaluate the Model ====
model <- arima(ts_train, order=c(3,1,3))
res <- residuals(model)
mse <- mean(res**2)
rmse <- sqrt(mse)
err_abspec <- abs(res)/ts_train
mape <- mean(
err_abspec[err_abspec != Inf]
)
cat("MSE:", mse, "RMSE:", rmse, "MAPE:", mape)
coeftest(model)
# Simple forecast
fore <- forecast::forecast(model, h=1, level=c(99))
autoplot(fore)
# Rolling forecast
rf <- c()
for (i in c(1: test_size)){
# Refit model
model <- arima(
head(ts_all, train_size+i-1),
# To predict the first element of the test set, we use the whole training set.
# To predict the k-th element of the test set (i.e. train_size+k th element), use all previouse train_size+k-1 elements.
order=c(3,1,3)
)
# Produce one step forecast
f <- forecast::forecast(model, h=1, level=c(99))
rf <- c(rf, f$mean)  # Add rolling forecast.
}
ts_rf <- ts(rf, start=time(ts_test)[1])
combined <- cbind("Rolling Forecast"=ts_rf, "Actual"=ts_test)
autoplot(combined) +
ggtitle("One Step Rolling Forecasting on Test Set") +
xlab("Date") +
ylab("Sunspot")
# Performance Metrics
mse_test <- mean((ts_rf - ts_test) ** 2)
rmse_test <- sqrt(mse_test)
cat("Test MSE:", mse, "RMSE:", rmse)
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=10, max.P=10, max.q=10, max.Q=10, max.d=3, max.D=3, trace=TRUE)
# ==== Fit and Evaluate the Model ====
model <- arima(ts_train, order=c(0,1,0))
res <- residuals(model)
mse <- mean(res**2)
rmse <- sqrt(mse)
err_abspec <- abs(res)/ts_train
mape <- mean(
err_abspec[err_abspec != Inf]
)
cat("MSE:", mse, "RMSE:", rmse, "MAPE:", mape)
coeftest(model)
# Simple forecast
fore <- forecast::forecast(model, h=1, level=c(99))
autoplot(fore)
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=10, max.P=10, max.q=10, max.Q=10, max.d=3, max.D=3, trace=TRUE)
# Train and test spliting
train_size <- as.integer(0.8 * length(ts_all))
test_size <- length(ts_all) - train_size
ts_train <- head(ts_all, train_size)
ts_test <- tail(ts_all, test_size)
# Forecasting of naive preddictor, as a baseline model.
baseline_error <- mean(
diff(ts_test) ** 2
)
cat(baseline_error)
autoplot(ts_train) +
ggtitle("Number of sunspots") +
xlab("Date") +
ylab("Exchange Rate") +
theme(plot.title = element_text(size=8, face="bold"))
# Determine the d number.
ndiffs(ts_train)
# Inspect the transformed sequence
transformed <- diff(ts_train, lag=1, differences=1)
ACF <- Acf(transformed, plot=TRUE, lag.max=34) # q=3
PACF <-Pacf(transformed, plot=TRUE, lag.max=34) # p=3
autoplot(transformed) +
ggtitle("Differenced Series") +
xlab("Date") +
ylab("Transformed")
# Test stationarity
adf.test(transformed)
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=10, max.P=10, max.q=10, max.Q=10, max.d=3, max.D=3, trace=TRUE)
# ==== Fit and Evaluate the Model ====
model <- arima(ts_train, order=c(1, 1, 1))
res <- residuals(model)
mse <- mean(res**2)
rmse <- sqrt(mse)
err_abspec <- abs(res)/ts_train
mape <- mean(
err_abspec[err_abspec != Inf]
)
cat("MSE:", mse, "RMSE:", rmse, "MAPE:", mape)
coeftest(model)
# Simple forecast
fore <- forecast::forecast(model, h=1, level=c(99))
autoplot(fore)
# Rolling forecast
rf <- c()
for (i in c(1: test_size)){
# Refit model
model <- arima(
head(ts_all, train_size+i-1),
# To predict the first element of the test set, we use the whole training set.
# To predict the k-th element of the test set (i.e. train_size+k th element), use all previouse train_size+k-1 elements.
order=c(3,1,3)
)
# Produce one step forecast
f <- forecast::forecast(model, h=1, level=c(99))
rf <- c(rf, f$mean)  # Add rolling forecast.
}
ts_rf <- ts(rf, start=time(ts_test)[1])
combined <- cbind("Rolling Forecast"=ts_rf, "Actual"=ts_test)
autoplot(combined) +
ggtitle("One Step Rolling Forecasting on Test Set") +
xlab("Date") +
ylab("Sunspot")
# Performance Metrics
mse_test <- mean((ts_rf - ts_test) ** 2)
rmse_test <- sqrt(mse_test)
cat("Test MSE:", mse, "RMSE:", rmse)
ts_rf
ts_test
rf
fore$level
fore$mean
fore$series
fore$fitted
ts_all
head(ts_train)
head(ts_train)
tail(ts_train)
library(fpp2)
library(ggfortify)
library(forecast)
library(stats)
library(aTSA)
library(lmtest)
#Set data directory path
setwd("C:/Teaching/Undergrad/data ECO374")
#Install and load required packages
chooseCRANmirror(graphics=FALSE, ind=33)
if (!require("urca")) install.packages("urca")
if (!require("tsDyn")) install.packages("tsDyn")
library(aTSA)
library(xts)
library(anytime)
library(urca)
library(tsDyn)
data_PCEC <- read.csv(file="PCEC.csv", header=TRUE, sep=",")
data_GDP <- read.csv(file="GDP.csv", header=TRUE, sep=",")
df <- read.csv("./data/DEXCAUS.csv", header=TRUE, sep=",", col.names=c("Date", "Exchange"))
df
df <- subset(df, Ex != ".")
df <- subset(df$Ex != ".")
df <- subset(df, Exchange != ".")
df
df <- read.csv("./data/DEXCAUS.csv", header=TRUE, sep=",", col.names=c("Date", "Exchange"))
head(df)
df
df <- subset(df, Exchange != ".")
df
head(ts_all)
ts_all <- ts(df$Ex)
head(ts_all0
head(ts_all)
ts_all
df
df <- subset(df, Exchange != ".")
df$Exchange
head(df$Exchange)
ts_all <- ts(df$Ex)
ts_all
# Train and test spliting
train_size <- as.integer(0.8 * length(ts_all))
test_size <- length(ts_all) - train_size
ts_train <- head(ts_all, train_size)
ts_train
test_size
ts_train
head(ts_train)
ts_train
std(train_size)
head(ts_train)
std(ts_train)
sd(ts_train)
sd(df$Exchange)
ts_all <- ts(df$Exchange)
ts_all
df
sd(df$Exchange)
setwd("/Users/tianyudu/Documents/Academics/EconForecasting/AnnEconForecast")
df <- read.csv("./data/DEXCAUS_cleaned.csv", header=TRUE, sep=",", col.names=c("Date", "Exchange"))
df <- subset(df, Exchange != ".")
ts_all <- ts(df)
ts_all
head(df)
ts_all <- ts(df, start=c(1971, 01, 04),frequency=1)
ts_all
ts_all <- ts(df, start=c(1971, 01, 04),frequency=30)
ts_all
ts_all <- ts(df, start=c(1971, 1, 04),frequency=30)
ts_all <- ts(df, start=c(1971, 1, 04),frequency=30)
ts_all
df
ts_all <- xts(x=df[c("Exchange")], order.by=anytime(df$Date))
ts_all
ts_all <- xts(x=df[c("Exchange")], order.by=anytime(df$Date))
# Train and test spliting
train_size <- as.integer(0.8 * length(ts_all))
test_size <- length(ts_all) - train_size
ts_train <- head(ts_all, train_size)
ts_test <- tail(ts_all, test_size)
baseline_error <- mean(
diff(ts_test) ** 2
)
diff(ts_test)
cat(baseline_error)
na.omit(diff(ts_test))
head(na.omit(diff(ts_test)))
head(diff(ts_test))
baseline_error <- mean(
na.omit(diff(ts_test)) ** 2
)
cat(baseline_error)
# Determine the d number.
ndiffs(ts_train)
# Inspect the transformed sequence
transformed <- diff(ts_train, lag=1, differences=1)
ACF <- Acf(transformed, plot=TRUE, lag.max=34) # q=3
PACF <-Pacf(transformed, plot=TRUE, lag.max=34) # p=3
autoplot(transformed) +
ggtitle("Differenced Series") +
xlab("Date") +
ylab("Transformed")
# Test stationarity
adf.test(transformed)
# Inspect the transformed sequence
transformed <- diff(ts_train, lag=1, differences=2)
# Test stationarity
adf.test(transformed)
# Inspect the transformed sequence
transformed <- diff(ts_train, lag=1, differences=3)
# Test stationarity
adf.test(transformed)
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=10, max.P=10, max.q=10, max.Q=10, max.d=3, max.D=3, trace=TRUE)
# ==== Fit and Evaluate the Model ====
model <- arima(ts_train, order=c(0, 1, 2))
res <- residuals(model)
mse <- mean(res**2)
rmse <- sqrt(mse)
err_abspec <- abs(res)/ts_train
ts_train
mape <- mean(
err_abspec[err_abspec != Inf]
)
coeftest(model)
# ==== Fit and Evaluate the Model ====
model <- arima(ts_train, order=c(0, 1, 2))
res <- residuals(model)
mse <- mean(res**2)
rmse <- sqrt(mse)
cat("MSE:", mse, "RMSE:", rmse, "MAPE:", mape)
?auto.arima
# Find the model minimizing AIC w/ correction.
auto.arima(ts_train, max.p=30, max.P=30, max.q=30, max.Q=30, max.d=3, max.D=3, stationary=TRUE, trace=TRUE)
# Find the model minimizing AIC w/ correction.
# auto.arima(ts_train, max.p=30, max.P=30, max.q=30, max.Q=30, max.d=3, max.D=3, stationary=TRUE, trace=TRUE)
auto.arima(max.order=30, stationary=TRUE, trace=TRUE)
# Find the model minimizing AIC w/ correction.
# auto.arima(ts_train, max.p=30, max.P=30, max.q=30, max.Q=30, max.d=3, max.D=3, stationary=TRUE, trace=TRUE)
auto.arima(ts_train, max.order=30, stationary=TRUE, trace=TRUE)
# Find the model minimizing AIC w/ correction.
# auto.arima(ts_train, max.p=30, max.P=30, max.q=30, max.Q=30, max.d=3, max.D=3, stationary=TRUE, trace=TRUE)
auto.arima(ts_train, max.order=30, stationary=FALSE, trace=TRUE)
# ==== Fit and Evaluate the Model ====
model <- arima(ts_train, order=c(0, 1, 2))
res <- residuals(model)
mse <- mean(res**2)
rmse <- sqrt(mse)
err_abspec <- abs(res) / ts_train
mape <- mean(
err_abspec[err_abspec != Inf]
)
ts_train
ts_train$Exchange
res
err_abspec <- abs(res) / as.matrix(ts_train)
mape <- mean(
err_abspec[err_abspec != Inf]
)
cat("MSE:", mse, "RMSE:", rmse, "MAPE:", mape)
